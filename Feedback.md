# 자동차 경주 게임 피드백
* 네이밍
    * 클래스 이름, 변수 이름, 메소드 이름은 되도록 의미 명확하게 짓기
    * 약어는 자제하기
    
* 객체 지향 생활 체조 원칙
    * 규칙 1: 한 메서드에 오직 한 단계의 들여쓰기(indent)만 한다.
        * 한 단계 이상의 들여쓰기가 나오는 경우는 대개 다음과 같은 듯 하다.
            * 중첩 반복문 - 반복 로직을 따로 메소드로 빼서 들여쓰기를 줄인다.
            * 반복문 속의 If문 - Java Stream을 적극 활용한다.
            * try-catch 문 - try 문 안의 로직 부분은 따로 메소드로 분리한다.
    * 규칙 2: else 예약어를 쓰지 않는다.
        * If 문에서 간단하게 해결하여 리턴할 수 있도록 리팩토링한다.
    * 규칙 3: 모든 원시값과 문자열을 포장한다.
        * 일급 컬렉션이나, 의미가 있는 객체를 생성한다.
    * 규칙 4: 한 줄에 점을 하나만 찍는다.
        * 규칙 3을 적용해서 객체화를 시키면 점이 줄어들긴 한다. 
    * 규칙 5: 줄여쓰지 않는다(축약 금지).
        * 그렇다고 한다.
    * 규칙 6: 모든 엔티티를 작게 유지한다.
        * 한 엔티티에 너무 많은 변수와 로직이 있다면 엔티티에 또 다른 엔티티나 vo로 두어서 분리한다.
    * 규칙 7: 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
        * 엔티티와 VO를 적극 활용한다.
        * _근데 이렇게 되면 너무 객체 depth가 깊어지지 않을까..?_
    * 규칙 8: 일급 콜렉션을 쓴다.
        * _단순 리스트나 맵도 일급 컬렉션으로 감싸면 객체 Depth가 깊어지는거 아닐까..?_
    * 규칙 9: 게터/세터/프로퍼티를 쓰지 않는다.
        * _이게 제일 어려운 듯._
        * 세터/프로퍼티 안쓰는 건 그렇다쳐도, 게터를 안쓰기란 정말 어렵다.
        * 단순한 게터를 적게 사용하려면, 객체가 직접 상태 데이터를 조작하도록 해야 한다.
        
* 객체 역할 분리하기
    * 객체의 역할을 구체적으로 해서, 되도록 분리시킨다.
    * Game 비즈니스 로직과 Game View 로직은 철저히 떼어놓아야 한다.
    
* Enum 활용하기
    * type-safe?한 연산을 사용하기 위해서 Enum을 적극 활용하자.
    * Enum 자체의 메소드를 적절히 사용해서 데이터를 잘 포장하자.
    
* 테스트 코드 작성하기
    * 비즈니스 로직을 구현하기 전에 테스트 코드를 작성한다.
    * 모든 public 메소드는 검증한다는 생각으로 작성한다.
    * 가능한 모든 예외 사항을 고려한다.
    * Junit의 Expected와 Actual을 혼동하지 말자.
    
        

